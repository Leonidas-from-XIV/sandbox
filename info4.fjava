int sumSeq(Seq<Integer> s) {
	if (isEmpty(rest(s))) return first(s);
	else {
		return first(s) + sumSeq(rest(s));
	}
}

int length(Seq<Integer> s) {
	if (isEmpty(s)) return 0;
	else {
		return 1 + length(rest(s));
	}
}

int altSumSeq(Seq<Integer> s) {
	return altSumSeq_(s, 1);
}

int altSumSeq_(Seq<Integer> s, int factor) {
	if (isEmpty(rest(s))) return first(s);
	else {
		return factor * first(s) + altSumSeq_(rest(s), -factor);
	}
}

int pow(int x, int y) {
	if (y == 0) return 1;
	else return x * pow(x, y - 1);
}

int bin2int_(Seq<Boolean> seq, int power) {
	if (isEmpty(rest(seq))) {
		final boolean var = first(seq);
		if (var) return 1;
		else return 0;
	}
	else {
		final boolean var = first(seq);
		if (var) {
			return pow(2, power) + bin2int_(rest(seq), power - 1);
		}
		else {
			return bin2int_(rest(seq), power - 1);
		}
	}
}

int length(Seq<Boolean> seq) {
	if (isEmpty(seq)) return 0;
	else return 1 + length(rest(seq));
}

int bin2int(Seq<Boolean> seq) {
	return bin2int_(seq, length(seq) - 1);
}

Seq<Boolean> int2bin(int i) {
	if (i / 2 == 0) {
		if (i % 2 == 1) return cons(true);
		else return cons(false);
	}
	else {
		final int div = i / 2;
		final int mod = i % 2;
		// append a true or false, depending on the modulo
		return concat(int2bin(div), cons(mod == 1));
	}
}

Seq<Boolean> reverse(Seq<Boolean> seq) {
	if (isEmpty(rest(seq))) return seq;
	else
		return concat(reverse(rest(seq)), cons(first(seq)));
}


Seq<Boolean> binadd_(Seq<Boolean> a, Seq<Boolean> b, boolean overflow) {
	final boolean afirst = first(a);
	final boolean bfirst = first(b);
	// adding the values directly together
	final boolean result1 = afirst ^ bfirst;
	// the number bit
	final boolean finalresult = result1 ^ overflow;
	// set if at least two of afirst bfirst and overflow are set
	final boolean finaloverflow = (afirst && bfirst) || ((afirst || bfirst) && overflow);
	
	return cons(finaloverflow, finalresult);
}

Seq<Boolean> binadd(Seq<Boolean> a, Seq<Boolean> b) {
	return binadd_(a, b, false);
}
